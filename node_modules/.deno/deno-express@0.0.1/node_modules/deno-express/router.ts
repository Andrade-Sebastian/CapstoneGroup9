import { pathToRegExp, IParsedPath } from './path-to-regexp.ts'

type RouterHandler = (req: any, res: any) => void

interface IRoute extends IParsedPath {
  method:
    | ''
    | 'GET'
    | 'HEAD'
    | 'OPTIONS'
    | 'POST'
    | 'PUT'
    | 'TRACE'
    | 'CONNECT'
    | 'PATCH'
    | 'DELETE'
  handlers: RouterHandler[]
}

export class Router {
  routes: IRoute[]

  constructor() {
    this.routes = []
  }

  use(route: string, ...handlers: RouterHandler[]) {
    let { keys, pattern } = pathToRegExp(route, true)
    this.routes.push({ keys, pattern, method: '', handlers })
    return this
  }

  add(method: IRoute['method'], route: string, ...handlers: RouterHandler[]) {
    let { keys, pattern } = pathToRegExp(route)
    this.routes.push({ keys, pattern, method, handlers })
    return this
  }

  find(method: IRoute['method'], url: string) {
    let isHEAD = method === 'HEAD'
    let i = 0,
      j = 0,
      k,
      tmp,
      arr = this.routes
    let matches,
      params: { [k: string]: any } = {},
      handlers: IRoute['handlers'] = []
    for (; i < arr.length; i++) {
      tmp = arr[i]
      if (
        tmp.method.length === 0 ||
        tmp.method === method ||
        (isHEAD && tmp.method === 'GET')
      ) {
        if (tmp.keys === false) {
          matches = tmp.pattern.exec(url)
          if (matches === null) continue
          if (matches.groups !== void 0)
            for (k in matches.groups) params[k] = matches.groups[k]
          tmp.handlers.length > 1
            ? (handlers = handlers.concat(tmp.handlers))
            : handlers.push(tmp.handlers[0])
        } else if (tmp.keys.length > 0) {
          matches = tmp.pattern.exec(url)
          if (matches === null) continue
          for (j = 0; j < tmp.keys.length; ) params[tmp.keys[j]] = matches[++j]
          tmp.handlers.length > 1
            ? (handlers = handlers.concat(tmp.handlers))
            : handlers.push(tmp.handlers[0])
        } else if (tmp.pattern.test(url)) {
          tmp.handlers.length > 1
            ? (handlers = handlers.concat(tmp.handlers))
            : handlers.push(tmp.handlers[0])
        }
      } // else not a match
    }

    return { params, handlers }
  }

  // Method aliases

  all(route: string, ...handlers: IRoute['handlers']) {
    return this.add('', route, ...handlers)
  }

  get(route: string, ...handlers: IRoute['handlers']) {
    return this.add('GET', route, ...handlers)
  }

  head(route: string, ...handlers: IRoute['handlers']) {
    return this.add('HEAD', route, ...handlers)
  }

  patch(route: string, ...handlers: IRoute['handlers']) {
    return this.add('PATCH', route, ...handlers)
  }

  options(route: string, ...handlers: IRoute['handlers']) {
    return this.add('OPTIONS', route, ...handlers)
  }

  connect(route: string, ...handlers: IRoute['handlers']) {
    return this.add('CONNECT', route, ...handlers)
  }

  delete(route: string, ...handlers: IRoute['handlers']) {
    return this.add('DELETE', route, ...handlers)
  }

  trace(route: string, ...handlers: IRoute['handlers']) {
    return this.add('TRACE', route, ...handlers)
  }

  post(route: string, ...handlers: IRoute['handlers']) {
    return this.add('POST', route, ...handlers)
  }

  put(route: string, ...handlers: IRoute['handlers']) {
    return this.add('PUT', route, ...handlers)
  }
}
