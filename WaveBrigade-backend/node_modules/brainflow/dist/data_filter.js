"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataFilter = void 0;
const koffi_1 = __importDefault(require("koffi"));
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const brainflow_types_1 = require("./brainflow.types");
const complex_1 = require("./complex");
const functions_types_1 = require("./functions.types");
class DataHandlerDLL extends functions_types_1.DataHandlerFunctions {
    constructor() {
        super();
        this.libPath = `${__dirname}/../brainflow/lib`;
        this.dllPath = this.getDLLPath();
        this.lib = this.getLib();
        this.getRailedPercentage = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_railed_percentage);
        this.performLowPass = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_lowpass);
        this.performHighPass = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_highpass);
        this.performBandPass = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_bandpass);
        this.performBandStop = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_bandstop);
        this.removeEnvironmentalNoise = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.remove_environmental_noise);
        this.writeFile = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.write_file);
        this.readFile = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.read_file);
        this.getNumElementsInFile = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_num_elements_in_file);
        this.performDownsampling = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_downsampling);
        this.performWaveletTransform = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_wavelet_transform);
        this.performInverseWaveletTransform =
            this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_inverse_wavelet_transform);
        this.performWaveletDenoising = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_wavelet_denoising);
        this.getWindow = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_window);
        this.performFft = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_fft);
        this.performIfft = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_ifft);
        this.getNearestPowerOfTwo = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_nearest_power_of_two);
        this.getPsd = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_psd);
        this.getPsdWelch = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_psd_welch);
        this.getBandPower = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_band_power);
        this.getCustomBandPowers = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_custom_band_powers);
        this.getOxygenLevel = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_oxygen_level);
        this.getHeartRate = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_heart_rate);
        this.restoreDataFromWaveletDetailedCoeffs =
            this.lib.func(functions_types_1.DataHandlerCLikeFunctions.restore_data_from_wavelet_detailed_coeffs);
        this.detectPeaksZScore = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.detect_peaks_z_score);
        this.performIca = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.perform_ica);
        this.getCsp = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_csp);
        this.detrend = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.detrend);
        this.calcStddev = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.calc_stddev);
        this.setLogLevelDataHandler = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.set_log_level_data_handler);
        this.setLogFileDataHandler = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.set_log_file_data_handler);
        this.logMessageDataHandler = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.log_message_data_handler);
        this.getVersionDataHandler = this.lib.func(functions_types_1.DataHandlerCLikeFunctions.get_version_data_handler);
    }
    getDLLPath() {
        const platform = os_1.default.platform();
        const arch = os_1.default.arch();
        switch (platform) {
            case 'darwin':
                return `${this.libPath}/libDataHandler.dylib`;
            case 'win32':
                return arch === 'x64' ? `${this.libPath}/DataHandler.dll` :
                    `${this.libPath}/DataHandler32.dll`;
            case 'linux':
                return `${this.libPath}/libDataHandler.so`;
            default:
                throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.GENERAL_ERROR, `OS ${platform} is not supported.`);
        }
    }
    getLib() {
        try {
            const lib = koffi_1.default.load(this.dllPath);
            return lib;
        }
        catch (err) {
            console.error(err);
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.GENERAL_ERROR, `${'Could not load DataHandlerDLL DLL - path://'}${this.dllPath}`);
        }
    }
    static getInstance() {
        if (!DataHandlerDLL.instance) {
            DataHandlerDLL.instance = new DataHandlerDLL();
        }
        return DataHandlerDLL.instance;
    }
}
class DataFilter {
    static setLogLevel(logLevel) {
        const res = DataHandlerDLL.getInstance().setLogLevelDataHandler(logLevel);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not set log level properly');
        }
    }
    static setLogFile(file) {
        const res = DataHandlerDLL.getInstance().setLogFileDataHandler(file);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not redirect to log file');
        }
    }
    static logMessage(logLevel, message) {
        const res = DataHandlerDLL.getInstance().logMessageDataHandler(logLevel, message);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not writte message');
        }
    }
    static getVersion() {
        const len = [0];
        let out = ['\0'.repeat(512)];
        const res = DataHandlerDLL.getInstance().getVersionDataHandler(out, len, 512);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not get version info');
        }
        return out[0].substring(0, len[0]);
    }
    static getRailedPercentage(data, gain) {
        const output = [0];
        const res = DataHandlerDLL.getInstance().getRailedPercentage(data, data.length, gain, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not get railed percentage');
        }
        return output[0];
    }
    static performLowPass(data, samplingRate, cutoff, order, filterType, ripple) {
        const res = DataHandlerDLL.getInstance().performLowPass(data, data.length, samplingRate, cutoff, order, filterType, ripple);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not apply filter');
        }
    }
    static performHighPass(data, samplingRate, cutoff, order, filterType, ripple) {
        const res = DataHandlerDLL.getInstance().performHighPass(data, data.length, samplingRate, cutoff, order, filterType, ripple);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not apply filter');
        }
    }
    static performBandPass(data, samplingRate, startFreq, stopFreq, order, filterType, ripple) {
        const res = DataHandlerDLL.getInstance().performBandPass(data, data.length, samplingRate, startFreq, stopFreq, order, filterType, ripple);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not apply filter');
        }
    }
    static performBandStop(data, samplingRate, startFreq, stopFreq, order, filterType, ripple) {
        const res = DataHandlerDLL.getInstance().performBandStop(data, data.length, samplingRate, startFreq, stopFreq, order, filterType, ripple);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not apply filter');
        }
    }
    static removeEnvironmentalNoise(data, samplingRate, noiseType) {
        const res = DataHandlerDLL.getInstance().removeEnvironmentalNoise(data, data.length, samplingRate, noiseType);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not apply filter');
        }
    }
    static writeFile(data, file, mode) {
        if (data.length == 0) {
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.INVALID_ARGUMENTS_ERROR, 'Empty data');
        }
        const flat = data.flat();
        const res = DataHandlerDLL.getInstance().writeFile(flat, data.length, data[0].length, file, mode);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not write file');
        }
    }
    static readFile(file) {
        const numElems = DataFilter.getNumElementsInFile(file);
        const dataArr = [...new Array(numElems).fill(0)];
        const rows = [0];
        const cols = [0];
        const res = DataHandlerDLL.getInstance().readFile(dataArr, rows, cols, file, numElems);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not read file');
        }
        return lodash_1.default.chunk(dataArr, cols[0]);
    }
    static getNumElementsInFile(file) {
        const output = [0];
        const res = DataHandlerDLL.getInstance().getNumElementsInFile(file, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not get info about file');
        }
        return output[0];
    }
    static performDownsampling(data, period, aggOperation) {
        if (period < 1) {
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.INVALID_ARGUMENTS_ERROR, 'invalid period');
        }
        const len = Math.trunc(data.length / period);
        const output = [...new Array(len).fill(0)];
        const res = DataHandlerDLL.getInstance().performDownsampling(data, data.length, period, aggOperation, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not perform downsampling');
        }
        return output;
    }
    static performWaveletDenoising(data, wavelet, decompositionLevel, waveletDenoising = brainflow_types_1.WaveletDenoisingTypes.SURESHRINK, threshold = brainflow_types_1.ThresholdTypes.HARD, extensionType = brainflow_types_1.WaveletExtensionTypes.SYMMETRIC, noiseLevel = brainflow_types_1.NoiseEstimationLevelTypes.FIRST_LEVEL) {
        const res = DataHandlerDLL.getInstance().performWaveletDenoising(data, data.length, wavelet, decompositionLevel, waveletDenoising, threshold, extensionType, noiseLevel);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not perform denosing');
        }
    }
    static getOxygenLevel(ppgIr, ppgRed, samplingRate, coef1 = 1.5958422, coef2 = -34.6596622, coef3 = 112.6898759) {
        const output = [0];
        const res = DataHandlerDLL.getInstance().getOxygenLevel(ppgIr, ppgRed, ppgIr.length, samplingRate, coef1, coef2, coef3, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calculate oxygen level');
        }
        return output[0];
    }
    static getHeartRate(ppgIr, ppgRed, samplingRate, fftSize) {
        const output = [0];
        const res = DataHandlerDLL.getInstance().getHeartRate(ppgIr, ppgRed, ppgIr.length, samplingRate, fftSize, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calculate heartrate');
        }
        return output[0];
    }
    static getCustomBandPowers(data, bands, channels, samplingRate, applyFilters = true) {
        if ((data.length == 0) || (bands.length == 0) || (channels.length == 0)) {
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.INVALID_ARGUMENTS_ERROR, 'Empty data');
        }
        var i;
        var j;
        const avgBands = [...new Array(bands.length).fill(0)];
        const stddevBands = [...new Array(bands.length).fill(0)];
        const data1D = [...new Array(data[0].length * channels.length).fill(0)];
        const startFreqs = [...new Array(bands.length).fill(0)];
        const stopFreqs = [...new Array(bands.length).fill(0)];
        for (i = 0; i < bands.length; i++) {
            startFreqs[i] = bands[i][0];
            stopFreqs[i] = bands[i][1];
        }
        for (i = 0; i < channels.length; i++) {
            for (j = 0; j < data[0].length; j++) {
                data1D[j + data[0].length * i] = data[channels[i]][j];
            }
        }
        const res = DataHandlerDLL.getInstance().getCustomBandPowers(data1D, channels.length, data[0].length, startFreqs, stopFreqs, bands.length, samplingRate, Number(applyFilters), avgBands, stddevBands);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calculate band powers');
        }
        return [avgBands, stddevBands];
    }
    static getAvgBandPowers(data, channels, samplingRate, applyFilters = true) {
        const bands = [[2.0, 4.0], [4.0, 8.0], [8.0, 13.0], [13.0, 30.0], [30.0, 45.0]];
        return DataFilter.getCustomBandPowers(data, bands, channels, samplingRate, applyFilters);
    }
    static getNearestPowerOfTwo(value) {
        const output = [0];
        const res = DataHandlerDLL.getInstance().getNearestPowerOfTwo(value, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not get nearest power');
        }
        return output[0];
    }
    static getWindow(windowFunction, len) {
        const output = [...new Array(len).fill(0)];
        const res = DataHandlerDLL.getInstance().getWindow(windowFunction, len, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not get window');
        }
        return output;
    }
    static performFft(data, windowType) {
        var i;
        if (data.length % 2 != 0) {
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.INVALID_ARGUMENTS_ERROR, "invalid input length");
        }
        const outputLen = Math.trunc(data.length / 2 + 1);
        const outputRe = [...new Array(outputLen).fill(0)];
        const outputIm = [...new Array(outputLen).fill(0)];
        const res = DataHandlerDLL.getInstance().performFft(data, data.length, windowType, outputRe, outputIm);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc fft');
        }
        const output = [];
        for (i = 0; i < outputLen; i++) {
            output.push(new complex_1.complex(outputRe[i], outputIm[i]));
        }
        return output;
    }
    static performIfft(data) {
        var i;
        const output = [...new Array(2 * (data.length - 1)).fill(0)];
        const tempRe = [...new Array(data.length).fill(0)];
        const tempIm = [...new Array(data.length).fill(0)];
        for (i = 0; i < data.length; i++) {
            tempRe[i] = data[i].real;
            tempIm[i] = data[i].img;
        }
        const res = DataHandlerDLL.getInstance().performIfft(tempRe, tempIm, output.length, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc ifft');
        }
        return output;
    }
    static getPsd(data, samplingRate, windowType) {
        if (data.length % 2 != 0) {
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.INVALID_ARGUMENTS_ERROR, "invalid input length");
        }
        const outputLen = Math.trunc(data.length / 2 + 1);
        const ampls = [...new Array(outputLen).fill(0)];
        const freqs = [...new Array(outputLen).fill(0)];
        const res = DataHandlerDLL.getInstance().getPsd(data, data.length, samplingRate, windowType, ampls, freqs);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc psd');
        }
        return [ampls, freqs];
    }
    static getPsdWelch(data, nfft, overlap, samplingRate, windowType) {
        if (data.length % 2 != 0) {
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.INVALID_ARGUMENTS_ERROR, "invalid input length");
        }
        const outputLen = Math.trunc(data.length / 2 + 1);
        const ampls = [...new Array(outputLen).fill(0)];
        const freqs = [...new Array(outputLen).fill(0)];
        const res = DataHandlerDLL.getInstance().getPsdWelch(data, data.length, nfft, overlap, samplingRate, windowType, ampls, freqs);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc psd');
        }
        return [ampls, freqs];
    }
    static getBandPower(psd, startFreq, stopFreq) {
        const output = [0];
        const res = DataHandlerDLL.getInstance().getBandPower(psd[0], psd[1], psd[0].length, startFreq, stopFreq, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc band power');
        }
        return output[0];
    }
    static performWaveletTransform(data, wavelet, decompositionLevel, extension) {
        const waveletCoeffs = [...new Array(data.length + 2 * (40 + 1)).fill(0)];
        const lengths = [...new Array(decompositionLevel + 1).fill(0)];
        const res = DataHandlerDLL.getInstance().performWaveletTransform(data, data.length, wavelet, decompositionLevel, extension, waveletCoeffs, lengths);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc wavelet transform');
        }
        const sum = lengths.reduce((a, b) => { return a + b; }, 0);
        const coeffsNew = waveletCoeffs.slice(0, sum);
        return [coeffsNew, lengths];
    }
    static performInverseWaveletTransform(waveletData, originalLen, wavelet, decompositionLevel, extension) {
        const output = [...new Array(originalLen).fill(0)];
        const res = DataHandlerDLL.getInstance().performInverseWaveletTransform(waveletData[0], originalLen, wavelet, decompositionLevel, extension, waveletData[1], output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc inverse wavelet transform');
        }
        return output;
    }
    static restoreDataFromWaveletDetailedCoeffs(data, wavelet, decompositionLevel, levelToRestore) {
        const output = [...new Array(data.length).fill(0)];
        const res = DataHandlerDLL.getInstance().restoreDataFromWaveletDetailedCoeffs(data, data.length, wavelet, decompositionLevel, levelToRestore, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not restore data from wavelet');
        }
        return output;
    }
    static detectPeaksZScore(data, lag = 5, threshold = 3.5, influence = 0.1) {
        const output = [...new Array(data.length).fill(0)];
        const res = DataHandlerDLL.getInstance().detectPeaksZScore(data, data.length, lag, threshold, influence, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not detect peaks');
        }
        return output;
    }
    static performIca(data, numComponents, channels) {
        if (data.length < 1) {
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.INVALID_ARGUMENTS_ERROR, "empty data");
        }
        var i;
        var j;
        const data1D = [...new Array(data[0].length * channels.length).fill(0)];
        const w = [...new Array(numComponents * numComponents).fill(0)];
        const k = [...new Array(channels.length * numComponents).fill(0)];
        const a = [...new Array(numComponents * channels.length).fill(0)];
        const s = [...new Array(data[0].length * numComponents).fill(0)];
        for (i = 0; i < channels.length; i++) {
            for (j = 0; j < data[0].length; j++) {
                data1D[j + data[0].length * i] = data[channels[i]][j];
            }
        }
        const res = DataHandlerDLL.getInstance().performIca(data1D, channels.length, data[0].length, numComponents, w, k, a, s);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not perform ica');
        }
        const wOut = [];
        while (w.length)
            wOut.push(w.splice(0, numComponents));
        const kOut = [];
        while (k.length)
            kOut.push(k.splice(0, channels.length));
        const aOut = [];
        while (a.length)
            aOut.push(a.splice(0, numComponents));
        const sOut = [];
        while (s.length)
            sOut.push(s.splice(0, data[0].length));
        return [wOut, kOut, aOut, sOut];
    }
    static detrend(data, detrendOperation) {
        const res = DataHandlerDLL.getInstance().detrend(data, data.length, detrendOperation);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not detrend');
        }
    }
    static calcStddev(data, startPos, stopPos) {
        const output = [0];
        const res = DataHandlerDLL.getInstance().calcStddev(data, startPos, stopPos, output);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not calc stddev');
        }
        return output[0];
    }
}
exports.DataFilter = DataFilter;
//# sourceMappingURL=data_filter.js.map