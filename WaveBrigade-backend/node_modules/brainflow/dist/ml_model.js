"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MLModel = exports.BrainFlowModelParams = void 0;
const koffi_1 = __importDefault(require("koffi"));
const lodash_1 = __importDefault(require("lodash"));
const os = __importStar(require("os"));
const brainflow_types_1 = require("./brainflow.types");
const functions_types_1 = require("./functions.types");
class BrainFlowModelParams {
    constructor(metric, classifier, inputParams) {
        this.inputParams = {
            metric: brainflow_types_1.BrainFlowMetrics.USER_DEFINED,
            classifier: brainflow_types_1.BrainFlowClassifiers.ONNX_CLASSIFIER,
            file: '',
            otherInfo: '',
            outputName: '',
            maxArraySize: 8192
        };
        this.inputParams = { ...this.inputParams, ...inputParams };
        this.inputParams.metric = metric;
        this.inputParams.classifier = classifier;
    }
    toJson() {
        const params = {};
        Object.keys(this.inputParams).forEach((key) => {
            params[lodash_1.default.snakeCase(key)] = this.inputParams[key];
        });
        return JSON.stringify(params);
    }
}
exports.BrainFlowModelParams = BrainFlowModelParams;
class MLModuleDLL extends functions_types_1.MLModuleFunctions {
    constructor() {
        super();
        this.libPath = `${__dirname}/../brainflow/lib`;
        this.dllPath = this.getDLLPath();
        this.lib = this.getLib();
        this.setLogLevelMLModule = this.lib.func(functions_types_1.MLModuleCLikeFunctions.set_log_level_ml_module);
        this.setLogFileMLModule = this.lib.func(functions_types_1.MLModuleCLikeFunctions.set_log_file_ml_module);
        this.logMessageMLModule = this.lib.func(functions_types_1.MLModuleCLikeFunctions.log_message_ml_module);
        this.getVersionMLModule = this.lib.func(functions_types_1.MLModuleCLikeFunctions.get_version_ml_module);
        this.prepare = this.lib.func(functions_types_1.MLModuleCLikeFunctions.prepare);
        this.predict = this.lib.func(functions_types_1.MLModuleCLikeFunctions.predict);
        this.release = this.lib.func(functions_types_1.MLModuleCLikeFunctions.release);
        this.releaseAll = this.lib.func(functions_types_1.MLModuleCLikeFunctions.release_all);
    }
    getDLLPath() {
        const platform = os.platform();
        const arch = os.arch();
        switch (platform) {
            case 'darwin':
                return `${this.libPath}/libMLModule.dylib`;
            case 'win32':
                return arch === 'x64' ? `${this.libPath}/MLModule.dll` :
                    `${this.libPath}/MLModule32.dll`;
            case 'linux':
                return `${this.libPath}/libMLModule.so`;
            default:
                throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.GENERAL_ERROR, `OS ${platform} is not supported.`);
        }
    }
    getLib() {
        try {
            const lib = koffi_1.default.load(this.dllPath);
            return lib;
        }
        catch (err) {
            console.error(err);
            throw new brainflow_types_1.BrainFlowError(brainflow_types_1.BrainFlowExitCodes.GENERAL_ERROR, `${'Could not load MLModule DLL - path://'}${this.dllPath}`);
        }
    }
    static getInstance() {
        if (!MLModuleDLL.instance) {
            MLModuleDLL.instance = new MLModuleDLL();
        }
        return MLModuleDLL.instance;
    }
}
class MLModel {
    constructor(metric, classifier, inputParams) {
        this.input = new BrainFlowModelParams(metric, classifier, inputParams);
        this.inputJson = this.input.toJson();
    }
    static getVersion() {
        const len = [0];
        let out = ['\0'.repeat(512)];
        const res = MLModuleDLL.getInstance().getVersionMLModule(out, len, 512);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not get version info');
        }
        return out[0].substring(0, len[0]);
    }
    static setLogLevel(logLevel) {
        const res = MLModuleDLL.getInstance().setLogLevelMLModule(logLevel);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not set log level properly');
        }
    }
    static setLogFile(file) {
        const res = MLModuleDLL.getInstance().setLogFileMLModule(file);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not redirect to log file');
        }
    }
    static logMessage(logLevel, message) {
        const res = MLModuleDLL.getInstance().logMessageMLModule(logLevel, message);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not writte message');
        }
    }
    prepare() {
        const res = MLModuleDLL.getInstance().prepare(this.inputJson);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not prepare model');
        }
    }
    predict(data) {
        const len = [0];
        const output = [...new Array(this.input.inputParams.maxArraySize).fill(0)];
        const res = MLModuleDLL.getInstance().predict(data, data.length, output, len, this.inputJson);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not predict');
        }
        return output.slice(0, len[0]);
    }
    release() {
        const res = MLModuleDLL.getInstance().release(this.inputJson);
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not release model');
        }
    }
    static releaseAll() {
        const res = MLModuleDLL.getInstance().releaseAll();
        if (res !== brainflow_types_1.BrainFlowExitCodes.STATUS_OK) {
            throw new brainflow_types_1.BrainFlowError(res, 'Could not release models');
        }
    }
}
exports.MLModel = MLModel;
//# sourceMappingURL=ml_model.js.map