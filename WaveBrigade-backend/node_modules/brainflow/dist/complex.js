"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.complex = void 0;
class complex {
    constructor(real, imaginary) {
        this._real = real;
        this._img = imaginary;
    }
    get real() {
        return this._real;
    }
    get img() {
        return this._img;
    }
    add(other) {
        return new complex(this._real + other.real, this._img + other.img);
    }
    sub(other) {
        return new complex(this._real - other.real, this._img - other.img);
    }
    mult(other) {
        return new complex(this.real * other.real - this._img * other.img, this.real * other.img + this._img * other.real);
    }
    div(other) {
        let ac = this._real * other.real;
        let bd = this._img * other.img;
        let bc = this._img * other.real;
        let ad = this._real * other.img;
        let cc = other.real * other.real;
        let dd = other.img * other.img;
        return new complex((ac + bd) / (cc + dd), (bc - ad) / (cc + dd));
    }
    scalarMult(lambda) {
        return new complex(lambda * this.real, lambda * this.img);
    }
    mag() {
        return Math.sqrt((this.real * this.real) + (this.img * this.img));
    }
    conj() {
        return new complex(this.real, -this.img);
    }
    neg() {
        return new complex(-this.real, -this.img);
    }
    arg() {
        return Math.atan2(this.img, this.real);
    }
    exp() {
        return new complex(Math.exp(this.real) * Math.cos(this.img), Math.exp(this.real) * Math.sin(this.img));
    }
    log() {
        return new complex(Math.log(this.mag()), Math.atan2(this.img, this.real));
    }
    sin() {
        return new complex(Math.cosh(this.img) * Math.sin(this.real), Math.sinh(this.img) * Math.cos(this.real));
    }
    cos() {
        return new complex(Math.cosh(this.img) * Math.cos(this.real), -Math.sinh(this.img) * Math.sin(this.real));
    }
    tan() {
        let num = this.sin();
        let denom = this.cos();
        return num.div(denom);
    }
    static fromPolar(theta, magnitude) {
        return new complex(magnitude * Math.cos(theta), magnitude * Math.sin(theta));
    }
    toPolar() {
        let mag = this.mag();
        let theta = this.arg();
        return [theta, mag];
    }
    toString() {
        if (Math.sign(this.img) === -1) {
            return this.real + " - " + -this.img + "i";
        }
        else {
            return this.real + " + " + this.img + "i";
        }
    }
    equals(other) {
        if (this.real === other.real && this.img === other.img) {
            return true;
        }
        else {
            return false;
        }
    }
}
exports.complex = complex;
//# sourceMappingURL=complex.js.map